<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Construction Check Sheet (Editable with Sign-off + Change Tracker + QR Unlock)</title>

<style>
  /* Wrapper for flex layout */
  .main-wrapper {
    display: flex;
    gap: 20px;
    max-width: 1200px;
    margin: auto;
  }

  /* Form container grows to fill */
  .container {
    flex-grow: 1;
    background: white;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 0 10px #ccc;
  }

  body {
    font-family: Arial, Helvetica, sans-serif;
    background: #f1f1f1;
    padding: 20px;
  }

  h2 {
    text-align: center;
    margin-bottom: 20px;
  }

  .section-header {
    background: #c8e6c9;
    padding: 12px 8px 8px 8px;
    font-weight: bold;
    border-radius: 4px;
    margin-top: 30px;
    position: relative;
  }

  /* Sign-off area styling */
  .signoff {
    background: #a5d6a7;
    border: 2px solid #388e3c;
    border-radius: 6px;
    padding: 12px;
    margin-top: 8px;
    display: flex;
    gap: 20px;
    align-items: center;
    flex-wrap: wrap;
  }
  .signoff label {
    font-weight: 600;
    min-width: 100px;
  }
  .signoff input {
    padding: 6px;
    font-size: 1rem;
    flex: 1 1 180px;
    min-width: 150px;
  }

  .row {
    display: grid;
    grid-template-columns: 1fr 120px 120px;
    gap: 10px;
    padding: 6px 0;
    border-bottom: 1px solid #ddd;
  }

  .row label {
    font-weight: 500;
  }

  input[type="checkbox"] {
    transform: scale(1.3);
    margin-left: 8px;
  }

  input[type="text"], input[type="date"] {
    width: 100%;
    padding: 6px;
  }

  textarea {
    width: 100%;
    padding: 10px;
    height: 80px;
  }

  .submit-container {
    margin-top: 20px;
    text-align: center;
  }

  button {
    background: #39ff14;
    padding: 18px 28px;
    font-size: 20px;
    border: none;
    border-radius: 10px;
    font-weight: bold;
    cursor: pointer;
  }

  /* Add row buttons */
  .add-row-btn {
    margin-top: 10px;
    font-weight: 600;
    cursor: pointer;
    color: #2e7d32;
    background: none;
    border: none;
    font-size: 1rem;
    text-decoration: underline;
  }

  /* Change tracker sidebar styles */
  #change-tracker-sidebar {
    width: 360px;
    background: #fff8dc;
    border: 1px solid #ddd;
    border-radius: 6px;
    padding: 16px;
    box-shadow: 0 0 8px rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
    height: fit-content;
    max-height: 80vh;
    position: sticky;
    top: 20px;
    font-family: monospace, monospace;
    font-size: 0.9rem;
  }

  #change-tracker-sidebar h3 {
    margin-top: 0;
  }

  #change-log {
    flex-grow: 1;
    max-height: 60vh;
    overflow-y: auto;
    background: #f9f9f9;
    border: 1px solid #ccc;
    padding: 8px;
    white-space: pre-wrap;
    margin-bottom: 12px;
  }

  #notify-controls {
    margin-bottom: 8px;
  }

  #notify-email-display {
    display: inline-block;
    font-size: 0.9rem;
    margin-right: 8px;
    color: #333;
    vertical-align: middle;
  }

  #set-notify-email-btn {
    padding: 6px 10px;
    font-size: 0.9rem;
    border-radius: 4px;
    background: #1976d2;
    color: white;
    border: none;
    cursor: pointer;
  }

  #unlock-log-btn, #clear-log-btn {
    padding: 8px 14px;
    font-size: 1rem;
    border-radius: 5px;
    border: none;
    cursor: pointer;
    margin-bottom: 8px;
    user-select: none;
  }

  #unlock-log-btn {
    background-color: #4caf50;
    color: white;
  }

  #clear-log-btn {
    background-color: #f44336;
    color: white;
  }

  #clear-log-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  #log-pass-error {
    color: #b00020;
    min-height: 1.2em;
  }

  /* QR code scanner container */
  #qr-reader {
    width: 320px;
    margin: 10px auto 20px;
    border: 2px solid #4caf50;
    border-radius: 8px;
  }

  /* Overlay when form is locked */
  #lock-overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.65);
    z-index: 9999;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 1.5rem;
    font-weight: bold;
    text-align: center;
  }

  /* Inline-edit display for disabled text inputs */
  .inline-span {
    display: inline-block;
    padding: 6px;
    min-height: 24px;
    border-radius: 4px;
    border: 1px solid transparent;
    background: transparent;
    cursor: text;
    width: 100%;
    box-sizing: border-box;
    color: #222;
  }
  .inline-span.placeholder {
    color: #888;
    font-style: italic;
  }
  .inline-span:hover {
    border-color: #ddd;
    background: #fff;
  }
</style>
</head>
<body>

<div class="main-wrapper">

  <div class="container">

    <form action="/submit-checksheet" method="post" id="main-form">

      <h2>Construction Check-sheet</h2>

      <div id="qr-reader"></div>
      <div id="lock-overlay">Scan QR code on badge to unlock the form</div>

      <div class="row">
        <label for="building">Building Number</label>
        <input type="text" id="building" name="building" disabled />
        <div></div>
      </div>

      <div class="row">
        <label for="phase">Phase</label>
        <input type="text" id="phase" name="phase" disabled />
        <div></div>
      </div>

      <div class="row">
        <label for="foreman">Foreman</label>
        <input type="text" id="foreman" name="foreman" disabled />
        <div></div>
      </div>

      <!-- Equipment Information Section -->
      <div class="section-header" id="equipment-info-header">Equipment Information</div>

      <div id="equipment-info-rows">
        <div class="row">
          <label for="elf-0">ELF Completed</label>
          <input type="checkbox" id="elf-0" name="elf[]" disabled />
          <input type="text" name="elf_notes[]" placeholder="Notes" disabled />
        </div>

        <div class="row">
          <label for="labels-0">Labels Installed by QCX: Phenolic / Arc Flash</label>
          <input type="checkbox" id="labels-0" name="labels[]" disabled />
          <input type="text" name="labels_notes[]" placeholder="Notes" disabled />
        </div>
      </div>

      <button type="button" class="add-row-btn" data-section="equipment-info" disabled>+ Add Equipment Info Row</button>

      <div class="signoff" id="signoff-equipment-info">
        <label for="signoff-equipment-name">Sign-Off Name:</label>
        <input type="text" id="signoff-equipment-name" name="signoff_equipment_name" placeholder="Name" disabled />
        <label for="signoff-equipment-date">Date:</label>
        <input type="date" id="signoff-equipment-date" name="signoff_equipment_date" disabled />
      </div>

      <!-- Equipment Mounted / Installation Specs Section -->
      <div class="section-header" id="equipment-mounted-header">Equipment Mounted / Installation Specs</div>

      <div id="equipment-mounted-rows">
        <div class="row">
          <label for="clearance-0">6” clearance from walls and panels</label>
          <input type="checkbox" id="clearance-0" name="clearance[]" disabled />
          <input type="text" name="clearance_notes[]" placeholder="Notes" disabled />
        </div>
        <div class="row">
          <label for="coverbolts-0">Remove front cover bolts</label>
          <input type="checkbox" id="coverbolts-0" name="coverbolts[]" disabled />
          <input type="text" name="coverbolts_notes[]" placeholder="Notes" disabled />
        </div>
        <div class="row">
          <label for="shipping-0">Shipping assembly (if required)</label>
          <input type="checkbox" id="shipping-0" name="shipping[]" disabled />
          <input type="text" name="shipping_notes[]" placeholder="Notes" disabled />
        </div>
        <div class="row">
          <label for="protect-0">Apply protect cover to equipment</label>
          <input type="checkbox" id="protect-0" name="protect[]" disabled />
          <input type="text" name="protect_notes[]" placeholder="Notes" disabled />
        </div>
        <div class="row">
          <label for="anchors-0">Anchored using 1/2” concrete wedge anchors</label>
          <input type="checkbox" id="anchors-0" name="anchors[]" disabled />
          <input type="text" name="anchors_notes[]" placeholder="Notes" disabled />
        </div>
        <div class="row">
          <label for="square-0">Housing is mounted squared and leveled</label>
          <input type="checkbox" id="square-0" name="square[]" disabled />
          <input type="text" name="square_notes[]" placeholder="Notes" disabled />
        </div>
      </div>

      <button type="button" class="add-row-btn" data-section="equipment-mounted" disabled>+ Add Installation Spec Row</button>

      <div class="signoff" id="signoff-equipment-mounted">
        <label for="signoff-mounted-name">Sign-Off Name:</label>
        <input type="text" id="signoff-mounted-name" name="signoff_mounted_name" placeholder="Name" disabled />
        <label for="signoff-mounted-date">Date:</label>
        <input type="date" id="signoff-mounted-date" name="signoff_mounted_date" disabled />
      </div>

      <!-- Internal Wiring and Termination Specs Section -->
      <div class="section-header" id="internal-wiring-header">Internal Wiring and Termination Specs</div>

      <div id="internal-wiring-rows">
        <div class="row">
          <label for="lineLoad-0">Install proper line/load wiring from nearest panel</label>
          <input type="checkbox" id="lineLoad-0" name="lineLoad[]" disabled />
          <input type="text" name="lineLoad_notes[]" placeholder="Notes" disabled />
        </div>
        <div class="row">
          <label for="primaryHV-0">Primary HV matches (L1-A, L2-B, L3-C)</label>
          <input type="checkbox" id="primaryHV-0" name="primaryHV[]" disabled />
          <input type="text" name="primaryHV_notes[]" placeholder="Notes" disabled />
        </div>
        <div class="row">
          <label for="phaseRotation-0">Verify primary phase rotation</label>
          <input type="checkbox" id="phaseRotation-0" name="phaseRotation[]" disabled />
          <input type="text" name="phaseRotation_notes[]" placeholder="Notes" disabled />
        </div>
        <div class="row">
          <label for="ground-0">Ground installation correct</label>
          <input type="checkbox" id="ground-0" name="ground[]" disabled />
          <input type="text" name="ground_notes[]" placeholder="Notes" disabled />
        </div>
      </div>

      <button type="button" class="add-row-btn" data-section="internal-wiring" disabled>+ Add Internal Wiring Row</button>

      <div class="signoff" id="signoff-internal-wiring">
        <label for="signoff-wiring-name">Sign-Off Name:</label>
        <input type="text" id="signoff-wiring-name" name="signoff_wiring_name" placeholder="Name" disabled />
        <label for="signoff-wiring-date">Date:</label>
        <input type="date" id="signoff-wiring-date" name="signoff_wiring_date" disabled />
      </div>

      <!-- Secondary Wiring Section -->
      <div class="section-header" id="secondary-wiring-header">Secondary Wiring</div>

      <div id="secondary-wiring-rows">
        <div class="row">
          <label for="secondaryWires-0">Secondary wires installed to labeling: X1-Black, X2-Red, X3-C, X4-Blue</label>
          <input type="checkbox" id="secondaryWires-0" name="secondaryWires[]" disabled />
          <input type="text" name="secondaryWires_notes[]" placeholder="Notes" disabled />
        </div>
      </div>

      <button type="button" class="add-row-btn" data-section="secondary-wiring" disabled>+ Add Secondary Wiring Row</button>

      <div class="signoff" id="signoff-secondary-wiring">
        <label for="signoff-secondary-name">Sign-Off Name:</label>
        <input type="text" id="signoff-secondary-name" name="signoff_secondary_name" placeholder="Name" disabled />
        <label for="signoff-secondary-date">Date:</label>
        <input type="date" id="signoff-secondary-date" name="signoff_secondary_date" disabled />
      </div>

      <!-- Final Checks Section -->
      <div class="section-header" id="final-checks-header">Final Checks</div>

      <div id="final-checks-rows">
        <div class="row">
          <label for="bondedBushing-0">Housing grounded via bonded bushing</label>
          <input type="checkbox" id="bondedBushing-0" name="bondedBushing[]" disabled />
          <input type="text" name="bondedBushing_notes[]" placeholder="Notes" disabled />
        </div>
        <div class="row">
          <label for="bondingJumper-0">Bonding jumper meets code</label>
          <input type="checkbox" id="bondingJumper-0" name="bondingJumper[]" disabled />
          <input type="text" name="bondingJumper_notes[]" placeholder="Notes" disabled />
        </div>
        <div class="row">
          <label for="notesAttached-0">Verify handwritten notes attached</label>
          <input type="checkbox" id="notesAttached-0" name="notesAttached[]" disabled />
          <input type="text" name="notesAttached_notes[]" placeholder="Notes" disabled />
        </div>
      </div>

      <button type="button" class="add-row-btn" data-section="final-checks" disabled>+ Add Final Check Row</button>

      <div class="signoff" id="signoff-final-checks">
        <label for="signoff-final-name">Sign-Off Name:</label>
        <input type="text" id="signoff-final-name" name="signoff_final_name" placeholder="Name" disabled />
        <label for="signoff-final-date">Date:</label>
        <input type="date" id="signoff-final-date" name="signoff_final_date" disabled />
      </div>

      <!-- QCX Review Section (non-repeatable) -->
      <div class="section-header" id="qcx-review-header">QCX Review</div>

      <div class="row">
        <label for="qcxName">Name</label>
        <input type="text" id="qcxName" name="qcxName" disabled />
        <div></div>
      </div>

      <div class="row">
        <label for="qcxDate">Date</label>
        <input type="date" id="qcxDate" name="qcxDate" disabled />
        <div></div>
      </div>

      <div class="submit-container">
        <button type="submit" disabled>SUBMIT CHECK SHEET</button>
      </div>

    </form>

  </div> <!-- container -->

  <div id="change-tracker-sidebar">
    <h3>Change Tracker (read-only)</h3>
    <div id="change-log">(No changes recorded)</div>

    <!-- Notification controls: set recipient email for sign-off notifications -->
    <div id="notify-controls">
      <span id="notify-email-display">(notify email not set)</span>
      <button id="set-notify-email-btn" title="Set recipient for sign-off notifications">Set Notification Email</button>
    </div>

    <button id="unlock-log-btn">Unlock Change Log</button>
    <button id="clear-log-btn" disabled>Clear Change Log</button>
    <div id="log-pass-error"></div>
  </div>

</div> <!-- main-wrapper -->

<!-- Html5Qrcode library -->
<script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>

<script>
  // === Rolling Change Tracker ===

  const changeLogDiv = document.getElementById('change-log');
  const unlockLogBtn = document.getElementById('unlock-log-btn');
  const clearLogBtn = document.getElementById('clear-log-btn');
  const passErrorDiv = document.getElementById('log-pass-error');

  let changeLog = [];

  function loadChangeLog() {
    const saved = localStorage.getItem('constructionChangeLog');
    if (saved) {
      try {
        changeLog = JSON.parse(saved);
      } catch {
        changeLog = [];
      }
      renderChangeLog();
    }
  }

  function saveChangeLog() {
    localStorage.setItem('constructionChangeLog', JSON.stringify(changeLog));
  }

  function renderChangeLog() {
    if (changeLog.length === 0) {
      changeLogDiv.textContent = '(No changes recorded)';
    } else {
      changeLogDiv.textContent = changeLog.join('\n');
      changeLogDiv.scrollTop = changeLogDiv.scrollHeight;
    }
  }

  function logChange(field, oldVal, newVal) {
    if (oldVal === newVal) return; // ignore no change
    const now = new Date().toLocaleString();
    const entry = `[${now}] ${field}: "${oldVal}" → "${newVal}"`;
    changeLog.push(entry);
    saveChangeLog();
    renderChangeLog();
  }

  unlockLogBtn.addEventListener('click', () => {
    const pass = prompt('Enter password to unlock the change log:');
    if (pass === '18436572') {
      changeLogDiv.contentEditable = "true";
      changeLogDiv.style.backgroundColor = '#ffffe0';
      clearLogBtn.disabled = false;
      passErrorDiv.textContent = '';
    } else {
      passErrorDiv.textContent = 'Incorrect password!';
    }
  });

  clearLogBtn.addEventListener('click', () => {
    if (confirm('Are you sure you want to clear the change log?')) {
      changeLog = [];
      saveChangeLog();
      renderChangeLog();
    }
  });

  loadChangeLog();

  // === Form Unlock via QR code ===

  const lockOverlay = document.getElementById('lock-overlay');
  const qrReaderDiv = document.getElementById('qr-reader');
  const mainForm = document.getElementById('main-form');

  let scannerActive = false;
  let qrScanner = null;
  let formIsDisabled = true; // track form disabled state (mirrors setFormDisabled)

  // Per-field temporary edit config
  const fieldUnlockEnabled = true;               // toggle to allow per-field edits while locked
  const fieldUnlockPassword = 'fieldunlock123';  // password required to temporarily unlock a single field

  // Disable all inputs and buttons initially
  function setFormDisabled(disabled) {
    formIsDisabled = !!disabled;

    const inputs = mainForm.querySelectorAll('input, button, textarea, select');
    inputs.forEach(input => {
      // keep control buttons in the sidebar unaffected
      if (input.id === 'unlock-log-btn' || input.id === 'clear-log-btn') return;
      // Keep checkboxes disabled/enabled as before
      if (input.type === 'checkbox' || input.type === 'radio' || input.tagName.toLowerCase() === 'select') {
        input.disabled = disabled;
      } else {
        // for text inputs & textareas we keep them disabled attribute, but inline-edit UI will handle showing spans
        input.disabled = disabled;
      }
    });

    // Disable Add Row buttons
    const addButtons = mainForm.querySelectorAll('.add-row-btn');
    addButtons.forEach(btn => {
      btn.disabled = disabled;
    });

    // Submit button follows same disabled state
    const submitBtn = mainForm.querySelector('button[type="submit"]');
    if (submitBtn) submitBtn.disabled = disabled;

    updateInlineDisplays();
  }

  setFormDisabled(true);

  // Inline edit helpers:
  // For text inputs and textareas, when they are disabled we display a span that shows the value.
  // When the form is unlocked (disabled=false) the actual inputs are shown for editing.
  function createSpanForInput(input) {
    const span = document.createElement('div');
    span.className = 'inline-span';
    const val = input.value || input.placeholder || '';
    if (!val) span.classList.add('placeholder');
    span.textContent = val || (input.placeholder || '');
    span.dataset.refInputName = input.name || input.id || '';
    // copy minimal styling to match width
    span.style.minHeight = getComputedStyle(input).height || '24px';

    span.addEventListener('click', () => {
      // If form is unlocked, behave exactly as before: show the real input
      if (!formIsDisabled) {
        span.style.display = 'none';
        input.style.display = '';
        input.disabled = false;
        input.focus();
        if (input.select) input.select();
        return;
      }

      // Form is locked. If per-field unlocks are disabled, notify user.
      if (!fieldUnlockEnabled) {
        alert('Unlock the form (scan QR) to edit this field.');
        return;
      }

      // Ask for per-field password (optional per-field unlock)
      const pass = prompt('Enter password to edit this single field (leave blank to cancel):');
      // If user cancelled prompt (pass===null) just return
      if (pass === null) return;

      if (pass === fieldUnlockPassword) {
        // Temporarily enable this input only
        span.style.display = 'none';
        input.style.display = '';
        input.disabled = false;
        input.dataset.tempUnlocked = 'true';
        input.focus();
        if (input.select) input.select();
      } else {
        alert('Incorrect password. Field remains locked.');
      }
    });

    return span;
  }

  // Swap inputs <-> spans depending on formIsDisabled
  function updateInlineDisplays() {
    // For all text-like controls: inputs[type=text], input[type=date], textarea
    const textSelectors = 'input[type="text"], input[type="date"], textarea, input[type="search"], input[type="tel"], input[type="email"]';
    const elements = mainForm.querySelectorAll(textSelectors);

    elements.forEach(el => {
      // ignore invisible template or fields that are not intended to be inline edited (we still support them)
      // If a span already exists right after this input, keep it
      let span = el.nextElementSibling && el.nextElementSibling.classList && el.nextElementSibling.classList.contains('inline-span') ? el.nextElementSibling : null;

      // If input was temporarily unlocked earlier, keep it visible regardless of global formIsDisabled,
      // until it blurs and attachBlurLogging handles re-hiding.
      const isTempUnlocked = el.dataset.tempUnlocked === 'true';

      if (formIsDisabled && !isTempUnlocked) {
        // show span, hide the input so it looks like read-only text
        if (!span) {
          span = createSpanForInput(el);
          el.parentNode.insertBefore(span, el.nextSibling);
        } else {
          // update span text to current input value
          const val = el.value || el.placeholder || '';
          span.textContent = val || (el.placeholder || '');
          span.classList.toggle('placeholder', !val);
        }
        el.style.display = 'none';
        el.disabled = true;
      } else {
        // form unlocked or this field is temporarily unlocked: remove span (if present) and show input
        if (span) span.remove();
        el.style.display = '';
        // If it's a temporary unlock, do not change disabled state here; leave input enabled.
        if (!isTempUnlocked) {
          el.disabled = false;
        }
      }
    });
  }

  // When an input loses focus we should update its span (if any), disable it again (if the whole form is still disabled),
  // and log changes.
  function attachBlurLogging(el) {
    el.addEventListener('blur', () => {
      const span = el.nextElementSibling && el.nextElementSibling.classList && el.nextElementSibling.classList.contains('inline-span') ? el.nextElementSibling : null;
      const oldVal = lastValues.get(el);
      const newVal = getInputValue(el);

      if (oldVal !== newVal) {
        const label = mainForm.querySelector(`label[for="${el.id}"]`);
        const fieldName = label ? label.textContent.trim() : el.name || el.id;
        logChange(fieldName, oldVal, newVal);
        lastValues.set(el, newVal);
      }

      // If this input was temporarily unlocked, clear that flag and restore disabled state + span
      if (el.dataset.tempUnlocked === 'true') {
        delete el.dataset.tempUnlocked;
        if (span) {
          span.textContent = el.value || el.placeholder || '';
          span.classList.toggle('placeholder', !el.value);
          el.style.display = 'none';
          el.disabled = true;
          span.style.display = '';
        } else {
          // create span if none existed
          updateInlineDisplays();
        }
        // If this element is a sign-off field, attempt to trigger notification now that it blurred.
        attemptSignoffNotificationForInput(el);
        return;
      }

      // For the normal case, if the form is supposed to be disabled after editing,
      // re-hide inputs if formIsDisabled is true. In our UX, inputs remain editable when the form is unlocked.
      if (formIsDisabled) {
        if (span) {
          span.textContent = el.value || el.placeholder || '';
          span.classList.toggle('placeholder', !el.value);
          el.style.display = 'none';
          el.disabled = true;
          span.style.display = '';
        } else {
          // no span present, nothing to do
          el.disabled = true;
        }
      }

      // If this element is a sign-off field, attempt to trigger notification now that it blurred.
      attemptSignoffNotificationForInput(el);
    });

    // allow Enter to finish editing for single-line inputs
    el.addEventListener('keydown', (ev) => {
      if (ev.key === 'Enter' && el.tagName.toLowerCase() === 'input') {
        ev.preventDefault();
        el.blur();
      }
    });
  }

  // Unlock form and stop scanner
  function unlockForm() {
    setFormDisabled(false);
    lockOverlay.style.display = 'none';
    qrReaderDiv.style.display = 'none';

    if (qrScanner) {
      qrScanner.stop().then(() => {
        console.log("QR Scanner stopped.");
      }).catch(e => {
        console.warn("Failed to stop scanner:", e);
      });
    }

    scannerActive = false;
  }

  // Start the scanner with fallback logic for camera facingMode
  function startScanner() {
    if (scannerActive) return;
    scannerActive = true;

    qrScanner = new Html5Qrcode("qr-reader");

    const config = { fps: 10, qrbox: { width: 250, height: 250 } };

    // Try environment camera first
    qrScanner.start(
      { facingMode: "environment" },
      config,
      qrCodeMessage => {
        const code = qrCodeMessage.trim();
        console.log("QR code scanned:", code);
        logChange('QR Scan Attempt', '(no old value)', code);

        if (/^\d{7}$/.test(code)) {
          console.log("Valid unlock code detected.");
          logChange('Form Unlock', '(locked)', `Unlocked with code: ${code}`);
          unlockForm();
        } else {
          console.log("Invalid code, ignoring.");
          logChange('Form Unlock Attempt Failed', '(locked)', `Attempted with code: ${code}`);
        }
      },
      errorMessage => {
        // Uncomment for debugging scan errors:
        // console.log("QR scan error:", errorMessage);
      }
    ).then(() => {
      console.log("QR Scanner started with environment camera.");
    }).catch(err => {
      console.warn("Failed environment camera start:", err);
      // fallback to user camera
      qrScanner.start(
        { facingMode: "user" },
        config,
        qrCodeMessage => {
          const code = qrCodeMessage.trim();
          console.log("QR code scanned:", code);
          logChange('QR Scan Attempt', '(no old value)', code);

          if (/^\d{7}$/.test(code)) {
            console.log("Valid unlock code detected.");
            logChange('Form Unlock', '(locked)', `Unlocked with code: ${code}`);
            unlockForm();
          } else {
            console.log("Invalid code, ignoring.");
            logChange('Form Unlock Attempt Failed', '(locked)', `Attempted with code: ${code}`);
          }
        },
        errorMessage => {
          // console.log("QR scan error:", errorMessage);
        }
      ).then(() => {
        console.log("QR Scanner started with user camera.");
      }).catch(err => {
        console.error("Failed user camera start:", err);
        scannerActive = false;
        alert('Failed to start camera for QR scanning. Please check camera permissions.');
      });
    });
  }

  // Start scanner on page load
  window.addEventListener('load', () => {
    startScanner();
    // create initial spans for disabled inputs
    updateInlineDisplays();
    loadNotifyEmailUI();
  });

  // === Track form changes to log them ===

  // Utility: get string value for input element
  function getInputValue(input) {
    if (!input) return '';
    if (input.type === 'checkbox') return input.checked;
    return input.value;
  }

  // Store initial values to compare changes
  const formElements = mainForm.querySelectorAll('input, textarea');
  const lastValues = new Map();

  formElements.forEach(el => {
    lastValues.set(el, getInputValue(el));
    // attach change logging for enabled controls
    el.addEventListener('change', () => {
      const oldVal = lastValues.get(el);
      const newVal = getInputValue(el);

      if (oldVal !== newVal) {
        const label = mainForm.querySelector(`label[for="${el.id}"]`);
        const fieldName = label ? label.textContent.trim() : el.name || el.id;
        logChange(fieldName, oldVal, newVal);
        lastValues.set(el, newVal);
      }
    });

    // For text-like elements attach blur handler to support inline-edit finalization
    const tagn = el.tagName.toLowerCase();
    if (tagn === 'textarea' || (el.type && (el.type === 'text' || el.type === 'date' || el.type === 'search' || el.type === 'tel' || el.type === 'email'))) {
      attachBlurLogging(el);
    }
  });

  // === Sign-off notification logic ===

  // Map of signoff sections to their name and date input IDs and friendly labels
  const signoffSections = {
    equipment: {
      nameId: 'signoff-equipment-name',
      dateId: 'signoff-equipment-date',
      label: 'Equipment Info Sign-off'
    },
    mounted: {
      nameId: 'signoff-mounted-name',
      dateId: 'signoff-mounted-date',
      label: 'Equipment Mounted Sign-off'
    },
    wiring: {
      nameId: 'signoff-wiring-name',
      dateId: 'signoff-wiring-date',
      label: 'Internal Wiring Sign-off'
    },
    secondary: {
      nameId: 'signoff-secondary-name',
      dateId: 'signoff-secondary-date',
      label: 'Secondary Wiring Sign-off'
    },
    final: {
      nameId: 'signoff-final-name',
      dateId: 'signoff-final-date',
      label: 'Final Checks Sign-off'
    },
    qcx: {
      nameId: 'qcxName',
      dateId: 'qcxDate',
      label: 'QCX Review'
    }
  };

  // localStorage key prefix for notifications
  const NOTIFIED_KEY_PREFIX = 'checksheet_notified_';
  const NOTIFY_EMAIL_KEY = 'checksheet_notify_email';

  // Exposed UI controls
  const setNotifyBtn = document.getElementById('set-notify-email-btn');
  const notifyEmailDisplay = document.getElementById('notify-email-display');

  function loadNotifyEmailUI() {
    const email = localStorage.getItem(NOTIFY_EMAIL_KEY) || '';
    notifyEmailDisplay.textContent = email ? `Notify: ${email}` : '(notify email not set)';
  }

  setNotifyBtn.addEventListener('click', () => {
    const current = localStorage.getItem(NOTIFY_EMAIL_KEY) || '';
    const input = prompt('Enter email address to receive sign-off notifications:', current);
    if (input === null) return; // cancelled
    const trimmed = (input || '').trim();
    if (trimmed) {
      localStorage.setItem(NOTIFY_EMAIL_KEY, trimmed);
      notifyEmailDisplay.textContent = `Notify: ${trimmed}`;
    } else {
      localStorage.removeItem(NOTIFY_EMAIL_KEY);
      notifyEmailDisplay.textContent = '(notify email not set)';
    }
  });

  // Helper to check if a section already triggered a notification
  function isSectionNotified(sectionKey) {
    return localStorage.getItem(NOTIFIED_KEY_PREFIX + sectionKey) === 'true';
  }

  function markSectionNotified(sectionKey) {
    localStorage.setItem(NOTIFIED_KEY_PREFIX + sectionKey, 'true');
  }

  // Compose a mailto: link and open user's mail client to create the email.
  // We use mailto because there's no backend configured; this ensures at least an email is composed.
  function sendSignoffEmail(recipient, subject, body) {
    // Basic URL-encoding
    const mailto = `mailto:${encodeURIComponent(recipient)}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
    // Attempt to open user's mail client
    window.location.href = mailto;
    // Log that we queued an email (even though the client handles sending)
    logChange('Notification', '(queued)', `Opened mail client for ${recipient} (${subject})`);
  }

  // Build body text with some context fields
  function buildSignoffEmailBody(sectionLabel, name, date) {
    const building = document.getElementById('building') ? document.getElementById('building').value : '';
    const phase = document.getElementById('phase') ? document.getElementById('phase').value : '';
    const foreman = document.getElementById('foreman') ? document.getElementById('foreman').value : '';

    let body = `${sectionLabel} completed.\n\n`;
    body += `Sign-off name: ${name}\n`;
    body += `Sign-off date: ${date}\n\n`;
    if (building) body += `Building: ${building}\n`;
    if (phase) body += `Phase: ${phase}\n`;
    if (foreman) body += `Foreman: ${foreman}\n`;
    body += `\n--\nThis email was generated from the Construction Check-sheet (in-browser).`;
    return body;
  }

  // Attempt to trigger notification for a section (if name & date present and not already notified)
  function attemptSignoffNotification(sectionKey) {
    const section = signoffSections[sectionKey];
    if (!section) return;

    const nameEl = document.getElementById(section.nameId);
    const dateEl = document.getElementById(section.dateId);
    if (!nameEl || !dateEl) return;

    const nameVal = (nameEl.value || '').trim();
    const dateVal = (dateEl.value || '').trim();

    if (!nameVal || !dateVal) return; // both must be present

    if (isSectionNotified(sectionKey)) return; // already notified previously

    // get recipient
    let recipient = localStorage.getItem(NOTIFY_EMAIL_KEY) || '';
    if (!recipient) {
      // ask the current user to provide a recipient email address
      recipient = prompt('Enter the email address that should receive sign-off notifications:');
      if (recipient === null) {
        // user cancelled; do not mark notified
        return;
      }
      recipient = (recipient || '').trim();
      if (!recipient) {
        alert('No email provided; notification cancelled.');
        return;
      }
      localStorage.setItem(NOTIFY_EMAIL_KEY, recipient);
      notifyEmailDisplay.textContent = `Notify: ${recipient}`;
    }

    // Compose email
    const subject = `${section.label} completed for ${document.getElementById('building') ? document.getElementById('building').value || 'building' : 'building'}`;
    const body = buildSignoffEmailBody(section.label, nameVal, dateVal);

    // Mark notified (so we don't send duplicate notifications) BEFORE opening mail client to avoid duplicates on quick repeated events.
    markSectionNotified(sectionKey);

    // Log and open mailto to let the user send (or it will open their mail client)
    sendSignoffEmail(recipient, subject, body);
  }

  // Called when an input blurs/changes to check if it belongs to a signoff and trigger attempt as needed.
  function attemptSignoffNotificationForInput(inputEl) {
    if (!inputEl || !inputEl.id) return;

    // iterate sections and see if this input belongs to any
    for (const key of Object.keys(signoffSections)) {
      const s = signoffSections[key];
      if (s.nameId === inputEl.id || s.dateId === inputEl.id) {
        attemptSignoffNotification(key);
        break;
      }
    }
  }

  // Attach listeners to signoff fields so notification logic runs when name/date get filled/edited.
  for (const key of Object.keys(signoffSections)) {
    const s = signoffSections[key];
    const nameEl = document.getElementById(s.nameId);
    const dateEl = document.getElementById(s.dateId);
    if (nameEl) {
      nameEl.addEventListener('change', () => attemptSignoffNotification(key));
      nameEl.addEventListener('blur', () => attemptSignoffNotification(key));
    }
    if (dateEl) {
      dateEl.addEventListener('change', () => attemptSignoffNotification(key));
      dateEl.addEventListener('blur', () => attemptSignoffNotification(key));
    }
  }

  // === Add row button logic ===

  function addRow(section) {
    const containerId = {
      'equipment-info': 'equipment-info-rows',
      'equipment-mounted': 'equipment-mounted-rows',
      'internal-wiring': 'internal-wiring-rows',
      'secondary-wiring': 'secondary-wiring-rows',
      'final-checks': 'final-checks-rows',
    }[section];

    if (!containerId) return;

    const container = document.getElementById(containerId);

    // Find current count of rows in section
    const rows = container.querySelectorAll('.row');
    const index = rows.length;

    // Template for new row (checkbox + notes)
    const newRow = document.createElement('div');
    newRow.className = 'row';

    let fieldBase = '';
    switch (section) {
      case 'equipment-info':
        fieldBase = 'elf';
        break;
      case 'equipment-mounted':
        fieldBase = 'clearance';
        break;
      case 'internal-wiring':
        fieldBase = 'lineLoad';
        break;
      case 'secondary-wiring':
        fieldBase = 'secondaryWires';
        break;
      case 'final-checks':
        fieldBase = 'bondedBushing';
        break;
      default:
        return;
    }

    // Create label
    const label = document.createElement('label');
    label.setAttribute('for', `${fieldBase}-${index}`);
    label.textContent = `New ${fieldBase} item ${index + 1}`;

    // Checkbox
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = `${fieldBase}-${index}`;
    checkbox.name = `${fieldBase}[]`;
    checkbox.disabled = formIsDisabled;

    // Notes input
    const notesInput = document.createElement('input');
    notesInput.type = 'text';
    notesInput.name = `${fieldBase}_notes[]`;
    notesInput.placeholder = 'Notes';
    notesInput.disabled = formIsDisabled;

    newRow.appendChild(label);
    newRow.appendChild(checkbox);
    newRow.appendChild(notesInput);

    container.appendChild(newRow);

    // Register in lastValues and attach logging + inline UI
    [checkbox, notesInput].forEach(el => {
      lastValues.set(el, getInputValue(el));
      el.addEventListener('change', () => {
        const oldVal = lastValues.get(el);
        const newVal = getInputValue(el);

        if (oldVal !== newVal) {
          const fieldName = label.textContent.trim() + (el.type === 'checkbox' ? ' (checked)' : ' (notes)');
          logChange(fieldName, oldVal, newVal);
          lastValues.set(el, newVal);
        }
      });
    });

    // For notesInput attach blur logging and create span if needed
    attachBlurLogging(notesInput);
    updateInlineDisplays();
  }

  // Attach event listeners to all add-row buttons
  const addRowButtons = document.querySelectorAll('.add-row-btn');
  addRowButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      if (btn.disabled) return;
      const section = btn.getAttribute('data-section');
      addRow(section);
    });
  });

  // Observe future additions to the form to ensure inline spans are created properly
  const observer = new MutationObserver(() => {
    updateInlineDisplays();
  });
  observer.observe(mainForm, { childList: true, subtree: true });

</script>

</body>
</html>
